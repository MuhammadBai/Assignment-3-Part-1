## Assignment-3-Part-1

# Task 1
___
## Q1: What is the benefit of creating a system user for this task rather than using a regular user or root?
Creating a system user like webgen ensures better security and organization:
* It provides security: A system user has limited privileges and is used only for specific tasks (like generating the index.html file). This reduces the risk of accidental changes compared to using the powerful root account.
* It keeps this task isolated from other regular user activities, making it easier to track which user is responsible for the task. It also ensures that files created (like index.html) are owned by webgen, avoiding conflicts with other users.
___

Lets start with task one which is to create the system user `webgen` with its home directory ar `/var/lib/webgen` and it's subdirectories `bin/` and `HTML/`

## `index.html` file

`index.html` file is the static HTML page which is generated by `generate_index` script and stored in `/var/lib/webgen/HTML` directory which has the following information:
* Kernel release of the system.
* Operating System in this case Arch Linux.
* Current date in `DD/MM/YYYY` format.
* Number of installed packages on the system.

#### Why we need this?
This is a dynamically generated HTML file that displays key system information. It is like a summary page that can be viewed in a browser.

*The file is designed to be easily viewed either through a web server or directly in a browser, offering a quick and clear snapshot of the system's current status. It's part of a larger automation process, such as the webgen utility, which regularly updates and presents the system's details. This helps you stay informed about things like the system's kernel version, operating system, installed packages, in a web format.*

## `generate_index` script
This Bash script generates and writes the `index.html` file.

**1) it sets strict error handling in case of errors**

`set -euo pipefail`
* set -e: The -e exits the script if any command fails.
* set -u: It treats unset variables as errors.
* pipefail: Capture errors in pipelines.

**2) Define variables**
```
KERNEL_RELEASE=$(uname -r)
OS_NAME=$(grep '^PRETTY_NAME' /etc/os-release | cut -d '=' -f2 | tr -d '"')
DATE=$(date +"%d/%m/%Y")
PACKAGE_COUNT=$(pacman -Q | wc -l)
OUTPUT_DIR="/var/lib/webgen/HTML"
OUTPUT_FILE="$OUTPUT_DIR/index.html"
```
### 1. `KERNEL_RELEASE=$(uname -r)`
* `uname -r`: This command outputs the version of the Linux kernel running on your system.
* `KERNEL_RELEASE=$(...)`: This syntax assigns the result of the uname `-r` command to a variable named `KERNEL_RELEASE`. So, this variable will store your system's kernel version inside of it.

### 2. `OS_NAME=$(grep '^PRETTY_NAME' /etc/os-release | cut -d '=' -f2 | tr -d '"')`
* `grep '^PRETTY_NAME' /etc/os-release`: This command searches for a line in the `/etc/os-release` file that begins with `PRETTY_NAME.` This file contains information about your operating system, and `PRETTY_NAME` typically holds a user-friendly name of the OS.
* `cut -d '=' -f2`: This command splits the line at the `=` sign and extracts the second part (after the =), which will be the OS name.
* `tr -d '"'`: This command removes any quotation marks (`"`) from the result. Some OS names in the file might be enclosed in quotes, so this ensures the name is clean.
* `OS_NAME=$(...)`: The result is assigned to the variable `OS_NAME`, which will store the name of the operating system, such as "Arch Linux".

### 3. `DATE=$(date +"%d/%m/%Y")`
* `date +"%d/%m/%Y"`: The date command formats the current date. The `+"%d/%m/%Y"` specifies the format: day (`%d`), month (`%m`), and year (`%Y`) in the `dd/mm/yyyy` format.
`DATE=$(...)`: The formatted date is assigned to the variable **DATE**. So, DATE will store the current date in `dd/mm/yyyy format`.

### 4. `PACKAGE_COUNT=$(pacman -Q | wc -l)`
* `pacman -Q`: This command lists all installed packages on an Arch Linux system (or systems using pacman as the package manager).
* `| wc -l`: This pipes (`|`) the output of the `pacman -Q` command into the `wc` (word count) command with the `-l` flag. The `-l` flag counts the number of lines.
* `PACKAGE_COUNT=$(...)`: The number of installed packages is stored in the variable `PACKAGE_COUNT`. So, `PACKAGE_COUNT` will store the total number of installed packages on the system.

### 5. `OUTPUT_DIR="/var/lib/webgen/HTML"`
* `OUTPUT_DIR="/var/lib/webgen/HTML"`: This line simply assigns the directory path `/var/lib/webgen/HTML` to the variable `OUTPUT_DIR`. This path will be used to store or output files.

### 6. `OUTPUT_FILE="$OUTPUT_DIR/index.html"`
* `$OUTPUT_DIR/index.html`: This references the `OUTPUT_DIR` variable and appends `index.html` to it, which means the full path will be `/var/lib/webgen/HTML/index.html`. This is where an HTML file will be saved or generated.
* `OUTPUT_FILE="$OUTPUT_DIR/index.html`": The full file path is stored in the variable `OUTPUT_FILE`.

#### To Summarize the above code:
* `KERNEL_RELEASE`: Stores the version of the Linux kernel.
* `OS_NAME`: Stores the name of the operating system.
* `DATE`: Stores the current date.
* `PACKAGE_COUNT`: Stores the number of installed packages.
* `OUTPUT_DIR`: Specifies the directory where HTML files will be saved.
* `OUTPUT_FILE`: Specifies the full path of the HTML file to be created.

### 3. Check and create target directory
```
if [[ ! -d "$OUTPUT_DIR" ]]; then
    echo "Error: Failed to create or access directory $OUTPUT_DIR." >&2
    exit 1
fi
```
Ensures the directory `/var/lib/webgen/HTML` exists. If not, it exits with an error message.
### 1. `if [[ ! -d "$OUTPUT_DIR" ]]`; then
* `[[ ... ]]`: This is a conditional expression in Bash, used to evaluate a test.
* `!`: This is a logical negation operator, meaning "not". It reverses the result of the test that follows.
* `-d "$OUTPUT_DIR"`: This checks if the directory stored in the `OUTPUT_DIR` variable exists. The `-d` option tests if the given path is a directory.
* `"$OUTPUT_DIR"`: This is the variable that stores the directory path (`/var/lib/webgen/HTML` in the previous example).
`if [[ ! -d "$OUTPUT_DIR" ]]`; then: The condition checks if the directory does not exist. If it doesn't exist, the code inside the if block will execute.

### 2. `echo "Error: Failed to create or access directory $OUTPUT_DIR." >&2`
* `echo`: This command prints text to the terminal.
* `"Error`: Failed to create or access directory `$OUTPUT_DIR`.": This is the error message that will be printed. It includes the `OUTPUT_DIR` variable, so it will display the full directory path in the message (e.g., "Error: Failed to create or access directory `/var/lib/webgen/HTML`.").
* `>&2`: This redirects the output of the echo command to standard error (stderr). By default, echo prints to standard output (stdout), but `>&2` ensures the error message goes to `stderr`, which is useful for error logging or handling.

### 3. `exit 1`
* `exit`: This command ends the script.
* `1`: The exit status code. In Unix-like systems, an exit status of 0 means success, and any non-zero value means an error. In this case, 1 indicates an error or abnormal termination of the script.
* `exit 1`: This ends the script with an error status (code 1) if the directory doesn't exist.

#### To Sum it up:
This part of the script checks if the directory specified in `OUTPUT_DIR` exists.
* if the directory doesnt exist, the script prints an error message to stderr and then exists with a status code 1 to indicate failure.
* if the directory does exist, the script continues with the next steps. 

**Explaination**

### 4. Generate the HTML file
The script uses a heredoc to dynamically create the HTML file with the retrieved data:
```
cat <<EOF > "$OUTPUT_FILE"
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System Information</title>
</head>
<body>
    <h1>System Information</h1>
    <p><strong>Kernel Release:</strong> $KERNEL_RELEASE</p>
    <p><strong>Operating System:</strong> $OS_NAME</p>
    <p><strong>Date:</strong> $DATE</p>
    <p><strong>Number of Installed Packages:</strong> $PACKAGE_COUNT</p>
</body>
</html>
EOF
```
### 1. `cat <<EOF > "$OUTPUT_FILE"`
* `cat`: This command reads and outputs the contents of a file or standard input. In this case, it's used in a "here document" to create a block of text.
* `<<EOF`: This is a "here document" syntax in Bash. It tells the shell to take the input that follows until it encounters the delimiter `EOF`. The text between `<<EOF` and `EOF` is treated as input for the command (in this case, the cat command).
* `> "$OUTPUT_FILE"`: The `>` operator redirects the output to a file. In this case, the output will be written to the file stored in the variable `OUTPUT_FILE`, which was defined earlier (e.g., `/var/lib/webgen/HTML/index.html`).ThisThis line opens a new HTML file or overwrites the file stored in `OUTPUT_FILE` and prepares to write the following HTML content into it.

#### To Finalize:
1. This script uses a here document to generate an HTML file and populate it with system information.
2. The file is written to the location specified in the `OUTPUT_FILE` variable `/var/lib/webgen/HTML/index.html`.
3. The values for kernel release, operating system, date, and package count are dynamically inserted into the HTML from the previously defined variables (`$KERNEL_RELEASE`, `$OS_NAME`, `$DATE`, `$PACKAGE_COUNT`).
**This script generates a system information page that can be viewed in a web browser.**

### 5. Check if the file was created( Error Handling)
```
if [ $? -eq 0 ]; then
    echo "Success: File created at $OUTPUT_FILE."
else
    echo "Error: Failed to create the file at $OUTPUT_FILE." >&2
    exit 1
fi
```
### 1. `if [ $? -eq 0 ]; then`
* `$?`: This special variable stores the exit status (or return code) of the last command that was executed.
If the last command was successful, `$?` will be `0`.
If the last command failed, `$?` will be a non-zero value.
* [ $? -eq 0 ]: This checks whether the exit status of the previous command is equal to 0. The `-eq` operator means "equal to".
If `$? is 0` the code inside the if block will run.
If `$? is not 0`  the code inside the else block will run.
if `[ $? -eq 0 ]`; then: This begins the if statement and checks whether the previous command was successful.

### 2. `echo "Success: File created at $OUTPUT_FILE`."
* `echo`: This command prints text to the terminal.
* `"Success: File created at $OUTPUT_FILE`.": This is the success message. The OUTPUT_FILE variable is included in the message, so it will display the full path of the file that was created (e.g., `/var/lib/webgen/HTML/index.html`).
* if $? is 0) the message will be printed.

### 3. `else`
The `else` part of the if statement specifies what to do if the condition `[ $? -eq 0 ]` is not true if the previous command failed.
If the previous command did not execute successfully, the script will execute the commands inside the else block.

### 4. `echo "Error: Failed to create the file at $OUTPUT_FILE." >&2`
* `echo`: This command prints text to the terminal.
* `"Error`: Failed to create the file at `$OUTPUT_FILE.`": This is the error message. It includes the `OUTPUT_FILE` variable, so the error message will display the path where the file creation failed which is `/var/lib/webgen/HTML/index.html).
* `>&2`: This redirects the output to standard error (stderr), instead of the default standard output (stdout). This is useful for logging or distinguishing error messages from regular output.
This message is printed if the previous command failed if $? is not 0.

### 5. `exit 1`
* `exit`: This command ends the script.
* `1`: The exit status code. In Unix-like systems, an exit status of `0` means success, and any non-zero value means an error. By using `exit 1`, the script signals an error condition and terminates.
* `exit 1`: This command will stop the script and return an error status if the file creation failed.w

### 6. `fi`
This closes the if statement. The if block must end with fi (fi is opposite of if).

*The script is designed to be run automatically at regular intervals such as through a cron job as we learned in the class or whenever needed, to refresh the system information shown in the index.html file. This ensures that the displayed details are always up to date, whether you’re viewing them regularly or on-demand*

**Why is this important?**

The `index.html` stays in `/var/lib/webgen/HTML` to keep it organized and seperate from other system files.
The `generate_index` script is stored in `/var/lib/webgen/bin` because binaries which are executable files are commonly kept in a bin directory.
These locations align with Linux's standard filesystem hierarchy.

**After above Next steps!**
Test the `generate_index` script:
Run the script and ensure the `index.html` file is correctly generated with up-to-date information.

**Serve the file via a web server**: To make this file accessible over the network, we will configure a web server linginx to serve /var/lib/webgen/HTML.

**Important** 
It is important that the directory is created and owned by `webgen` system user before running the script if the directory `/var/lib/webgen/HTML` does not exist it will return an error!
___

# Task 2

## generate-index.service file
___
## Q2. How will you verify that the timer is active and that the service runs successfully?

You can check if the timer and service are working by reviewing their status and logs:

1. Check if the timer is active:
`sudo systemctl list-timers | grep generate-index.timer`
This will show if the timer is active and when it is scheduled to run next.
2. Check the service’s success: Run:
`sudo journalctl -u generate-index.service`

## Q3. What commands can you run to check logs and to confirm the service's execution?
Here are the key commands:
1. Timer logs:
`sudo journalctl -u generate-index.timer`
This shows if the timer triggered the service on schedule.

2. Service logs:
`sudo journalctl -u generate-index.service`
This confirms if the generate_index script ran successfully or encountered issues.

3. Combined logs: To see logs for both the timer and service together:
`sudo journalctl -u generate-index.timer -u generate-index.service`
___

```
[Unit]
# Description of the service
Description=Generate daily system information index.html at 05:00

[Service]
# Use the webgen user and group
User=webgen
Group=webgen
# Specify the script to execute
ExecStart=/var/lib/webgen/bin/generate_index
# Ensure the working directory is where the the HTML file will be
WorkingDirectory=/var/lib/webgen/bin
Type=oneshot

[Install]
WantedBy=multi-user.target
```
**Explaination**
### 1. [Unit] Section:
* `Description=`
This part explains what the service is for. this is generating the index.html file, which contains important system information.

### 2. [Service] Section:
* `User=webgen, Group=webgen`
This ensures that the service runs under the webgen user and group, which helps keep things secure. It prevents the service from running with higher privileges like root, which could be risky.

* `ExecStart=/var/lib/webgen/bin/generate_index`
This is the full path to the script that the service will run, named `generate_index`. This script is responsible for doing the main job — generating the index.html file.

* `WorkingDirectory=/var/lib/webgen/bin`
This tells the service where to "start" or work from, which in this case is the `/var/lib/webgen/bin directory`. This is important for handling relative paths in the script, meaning if the script refers to files without giving the full path, the system will look for those files inside this directory.

* `Type=oneshot`
This setting tells the system that the service will run the task once and then stop. It doesn’t need to keep running because the task is done once the index.html file is generated.

### 3. [Install] Section:
WantedBy=multi-user.target
This specifies that the service should be activated in a multi-user environment. This is a typical setup for a system that supports multiple users.
This service makes sure the generate_index script runs securely, under the correct user, and does its job of creating the index.html file. It is triggered by a generate-index.timer (timer unit), meaning it runs automatically at set times (like every day, week, etc.) to keep the information updated.

#### What are relative paths?

*A relative path is a way to specify the location of a file or directory in relation to the current working directory. when we say "relative paths", we mean that if the script refers to a file without using the full path (e.g., /home/user/file.txt), it will look for that file based on the current working directory set in the WorkingDirectory directive (which is /var/lib/webgen/bin in this case). So, the script will search for files relative to that directory.*

Testing the generate-index.service
Before setting up the timer, it’s important to verify that the service itself works as intended. Here's how you can test it step by step:

## Next Steps to reload the systmed: 

### 1. To Reload systemd to recognize the new service file
After creating the generate-index.service file, you must inform systemd of the changes by typing following command:
`sudo systemctl daemon-reload`

### 2. To Manually start the service
Start the service manually to check if it works:
`sudo systemctl start generate-index.service`

### 3. Check the service status
Verify whether the service executed successfully from the following:
`sudo systemctl status generate-index.service`

If successful, you’ll see a status indicating Active: inactive (dead) with no errors (because it is a oneshot service and exits after completing its task).
If there’s an error, inspect the output for issues such as file permissions, script errors, or incorrect paths.

### 4. Verifying the output
Check if the `index.html` file was successfully generated in `/var/lib/webgen/HTML`.

This command will make sure:
    `cat /var/lib/webgen/HTML/index.html`
the file contains valid HTML with up-to-date system information.

### 5. Checking system logs for errors
If the service fails, to see the errors and logs type:
`sudo journalctl -u generate-index.service`

Common errors to look for:
Permission issues: Ensure the webgen user has write access to /var/lib/webgen/HTML.
Script execution issues: Ensure the generate_index script is executable (chmod +x /var/lib/webgen/bin/generate_index).

### 6. Enable the service
If you want the service to start automatically during the boot process:
`sudo systemctl enable generate-index.service`
This step is optional during testing because the generate-index.timer file will automate the service execution at 05 everyday.

**To address the Issues**
If any step fails:
1. Double-check the paths specified in the ExecStart and WorkingDirectory fields of the service file.
2. See that the `generate_index script` is working correctly by running it manually:
`sudo -u webgen /var/lib/webgen/bin/generate_index`
3. Inspect the permissions of all relevant files and directories.

## generate-index.timer file
```
[Unit]
# Description of the timer
Description=Timer to run generate-index.service everyday at 05:00

[Timer]
# this Run the service every day at 05:00
OnCalendar=*-*-* 05:00:00
Persistent=true

[Install]
# timer starts at boot
WantedBy=timers.target
```
The generate-index.timer file is a timer unit in systemd that schedules the generate-index.service to run daily at 05:00. Here’s how you can test and validate the timer setup:

### 1. [Unit] Section
This part describes the timer and what it’s for.
Description=Timer to run generate-index.service every day at 05:00
This is a short description of what the timer does. It explains that the timer will activate the generate-index.service daily at 5:00 AM.

### 2. [Timer] Section
This part defines how and when the timer works.
* `OnCalendar=-- 05:00:00*`
This sets the schedule for the timer.
* The `*-*-*` means "every year, every month, every day."
* `05:00:00` means "at 5:00 AM."
This means the timer will activate daily at 5:00 AM.
* `Persistent=true`
This ensures the timer "remembers" missed events if the system was off at the scheduled time.
For example, if the system was off at 5:00 AM, the timer will immediately run the service when the system turns back on.

### 3. [Install] Section
This part defines when and how the timer starts.
`WantedBy=timers.target`
This makes the timer part of the `timers.target`, which is a `systemd` group for timers.
It ensures the timer starts automatically when the system boots.

*What This Timer Does*
*At 5:00 AM every day, the timer activates the generate-index.service.
If the system was off at 5:00 AM, the Persistent=true setting ensures the service still runs once the system is back online.
It works like a daily alarm clock for the generate-index.service.*

**Important Information**
### Timers in systemd:
Timers are like schedulers that tell the system when to run a specific service. It is like an automated reminder for tasks.

### Timers vs. Cron:
Systemd timers are similar to cron jobs but are more integrated with the rest of the system, offering features like Persistent=true.

*Why This is Useful?
This timer ensures the system automatically generates the index.html file without without changing manually. It keeps the file up to date and ensures no updates are missed, even if the system was offline at the scheduled time.*

## Next Steps
#### To reload: `sudo systemctl daemon-reload`
#### To Enable: `sudo systemctl enable generate-index.timer`
#### To Start the timer: `sudo systemctl start generate-index.timer`
#### To check the timer's specific status: `sudo systemctl status generate-index.timer`
#### To check that the timer is active and when it is scheduled to trigger: `sudo systemctl list-timers --all | grep generate-index`

**To verify logs**
it will show that the timer triggered the service correctly.
`sudo journalctl -u generate-index.timer`
`sudo journalctl -u generate-index.service`
 --
# Task 3

 ## Nginx.conf file
___
## Q4. Why is it important to use a separate server block file instead of modifying the main nginx.conf file directly?
Using a separate server block file (e.g., `/etc/nginx/conf.d/server_block.conf`) keeps your configuration easier to manage, and Organizing your server block configuration in a separate file makes managing your Nginx setup much easier and safer. It keeps your site-specific settings separate from the main Nginx configuration which ensures that everything stays clean and well-structured. If there’s a mistake in your server block, it won’t affect the entire server, so other configurations can still run smoothly. This setup is also scalable which means you can quickly add new server blocks for additional websites or services without needing to change the main configuration file which keeps everything organized and easy to maintain.

## Q5. How can you check the status of the NGINX service and test your NGINX configuration?
Check NGINX service status:
`sudo systemctl status nginx`
This shows if NGINX is running, stopped, or has errors.

Test NGINX configuration for syntax errors:
`sudo nginx -t`
If there are no issues, it outputs:
the configuration file `/etc/nginx/nginx.conf` syntax is ok
configuration file `/etc/nginx/nginx.conf` test is successful

Reload NGINX after changes:
`sudo systemctl reload nginx`
___

 ```
user webgen;
worker_processes auto;
worker_cpu_affinity auto;


events {
	multi_accept on;
	worker_connections  1024;
}

http {
    charset utf-8;
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    server_tokens off;
    log_not_found off;
    types_hash_max_size 4096;
    client_max_body_size 16M;

    # MIME
    include mime.types;
    default_type application/octet-stream;

    # logging
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log warn;

    # this ensures that Nginx loads all .conf files in /etc/nginx/conf.d/, which is where your new server block configuration file should go
    include /etc/nginx/conf.d/*.conf;

    # Include server blocks from sites-enabled directory
    include /etc/nginx/sites-enabled/*;
    }
```
This file configures Nginx, a web server, to handle request smoothly:

### General Settings
* `user webgen`;
This tells Nginx to run under the webgen user account instead of a powerful root account, which is safer.
* `worker_processes auto`;
Nginx will figure out how many CPU cores are available and use them all to maximize performance.
* `worker_cpu_affinity auto`;
Automatically assigns worker processes to specific CPU cores for smooth multitasking.

### Managing the connection
* `multi_accept on`;
It allows Nginx accept multiple incoming connections at once, so it handles many visitors faster.
* `worker_connections 1024`;
Each worker process can manage up to 1024 connections at the same time, enough for most servers.

### Web Request Settings
This section fine-tunes how Nginx deals with HTTP traffic.
* `charset utf-8`;
Ensures text content is displayed correctly, using the standard UTF-8 format.
* `sendfile on`;
Speeds up file downloads by sending files directly from disk to the visitor’s browser.
* `tcp_nopush on`;
Optimizes sending large files by bundling data into fewer, bigger packets.
* `tcp_nodelay on`;
Reduces delays for smaller data, like instant chat messages or quick interactions.
* `server_tokens off`;
Hides the Nginx version to keep hackers guessing and improve security.
* `log_not_found off`;
Stops logging every "file not found" error to keep the logs clean.
* `types_hash_max_size 4096`;
Adjusts the settings for file type which is .html or .jpg for better speed.
* `client_max_body_size 16M`;
Limits uploads to 16 MB per request, which is helpful to avoid overloading the server.

### It is Handling File Types
* `include mime.types`;
Loads a list of file extensions .html and their corresponding types.
* `default_type application/octet-stream`;

### Logging
* `access_log /var/log/nginx/access.log`;
Keeps a record of all successful visitor requests to the server.
* `error_log /var/log/nginx/error.log warn`;
Logs any issues or warnings in the server’s error log for troubleshooting.

### Flexible Configurations
* `include /etc/nginx/conf.d/*.conf`;
Nginx will load any extra configuration files from this directory. it is good to add specific feature without cluttering the main file. 
* `include /etc/nginx/sites-enabled/*`;
Adds server-specific configurations from the sites-enabled directory which is helpul for hosting multiple websites.

### What Does This All Do?
This setup is designed to make your web server:

1. This is fast because It uses all your CPU resources and has efficient file-handling features.
2. This is secure because it limits permissions and hides sensitive information.
3. This is organized, so you can easily add or modify settings.
4. This is reliable because it manages connections and traffic effectively, even for large numbers of visitors.

This setup is designed to let Nginx serve the `index.html` file. By adding custom server block configurations in `/etc/nginx/conf.d`, we tell Nginx exactly how to display the index.html file located in `/var/lib/webgen/HTML/`. This ensures Nginx knows how to handle requests and show the file to visitors.

## Next Steps:
#### Test the configuration for syntax errors: `sudo nginx -t`
#### Reload NGINX to apply changes: `sudo systemctl reload nginx`

## Server_block.conf file
```
server {
    listen 80;
    listen [::]:80;
    server_name 137.184.10.176;
    root /var/lib/webgen/HTML;
    index index.html;

    location / {
        try_files $uri $uri/ =404;
    }
}
```
What Does server_block.conf Do?
This file is a set of instructions for Nginx web server to define how it should handle requests and serve files. It ensures your system information page which is index.html is accessible over the web.

#### Explaination for server_block.conf

### 1. Listening Requests
```
listen 80;
listen [::]:80;
```
These directives tell NGINX to listen on IPv4 and IPv6 addresses on port 80 which is the default http port.
This makes sure that NGINX can accept incoming HTTP requests on both IPv4 and IPv6 networks.

**This ensures users can connect to your server no matter which type of IP address they use.**

### 2. Giving the Server's Address
`server_name 137.184.10.176;`
It defines the IP address or domain name that Nginx responds to, in this case this is my server’s IP: 137.184.10.176.

**Nginx knows to handle requests only for this IP address for the different domain you will replace their IP.** 

### 3. Setting the File Location
```
root /var/lib/webgen/HTML;
index index.html;
```
root: Tells Nginx where to find the files to serve. Here, it's /var/lib/webgen/HTML.
index: Specifies the default file (like index.html) that users see when visiting your site.

**This makes sure Nginx serves the index.html file generated by your script when someone visits http://137.184.10.176/.**

### 4. Handling Requests
```
location / {
    try_files $uri $uri/ =404;
}
```
It checks if the requested file exists which is `$uri`.
If it doesn't, checks if a directory exists `$uri/`.
If neither exists, returns a 404 Not Found error.

**It prevents Nginx from serving incorrect or missing files. Only valid files or directories are displayed.
Purpose of This File**

This configuration does three key things:
1. It makes the index.html file available online at http://137.184.10.176/.
2. It ensures that only valid files or directories are served; anything else returns a 404 error.
3. It keeps it organized by specifying the file location and default file, Nginx knows exactly what to serve and from where.

Why This is Important
Automates Access: Once your system information page `index.html` is generated, this file ensures it's automatically available via a browser.
Users can easily access the latest system details by visiting the server’s IP or domain.

# Task 4
___
## Q6 How can you check the status of the firewall:
with the following command: `sudo ufw status verbose`
___

## Firewall Configuration with UFW
To secure the server while serving the HTML document that contaoins system information, I configured a firewall using UFW (Uncomplicated Firewall).

Below are the steps I followed:

### 1. Install and Enable UFW
Installed UFW using the Arch Linux package manager:
`sudo pacman -S ufw`
Enabled and started the UFW service:
`sudo systemctl enable --now ufw.service`

### 2. Default UFW Rules
Set the default policies:
Deny all incoming traffic:
`sudo ufw default deny incoming`
Allow all outgoing traffic
`sudo ufw default allow outgoing`

### 3. Configure Rules
Allowed SSH connections from anywhere:
`sudo ufw allow ssh`
Rate-limited SSH to prevent brute force attacks (max 6 attempts in 30 seconds):
`sudo ufw limit ssh`
Allowed HTTP connections for serving web traffic:
`sudo ufw allow http`

### 4. Enable the Firewall
Turned on the firewall:
`sudo ufw enable`

### 5. Verify Firewall Configuration
Checked the firewall status to ensure the rules were active:
`sudo ufw status verbose`
The output confirmed that SSH and HTTP were allowed, and SSH rate-limiting was in place.

# Task 5

My ip address: 137.184.10.176

___
## Q7. Can you think of ways to enhance the generate_index script to include additional system information or error handling?

To enhance some ideas i think of:
1. including cpu information like speed and model:
`lscpu | grep "Model name"`

Improved Error Handling:
Check if the `/var/lib/webgen/HTML` directory exists before proceeding.
Log errors to a file for troubleshooting.
Add more descriptive error messages for missing tools like uname or pacman.
___


